
### Основы сортировки 
Сегодня мы разберем, что такое сортировка, почему она важна, и изучим три популярных алгоритма: **сортировку вставками (Insertion Sort)**, **сортировку выбором (Selection Sort)** и **быструю сортировку (Quick Sort)**. 

#### Почему сортировка важна?
Сортировка — это процесс упорядочивания элементов в списке или массиве по определённому критерию, например, по возрастанию или убыванию. До появления компьютеров сортировка данных была серьёзной проблемой: её выполнение вручную занимало огромное количество времени. Например, в 1890-х годах компания *Tabulating Machine Company* (позже ставшая *IBM*) автоматизировала операции сортировки, что позволило обработать данные переписи населения США на несколько лет быстрее.

Сегодня сортировка — одна из ключевых операций в программировании. Она используется в поиске данных, оптимизации алгоритмов и многих других задачах. Существует множество алгоритмов сортировки, каждый из которых имеет свои плюсы и минусы. В этой лекции мы сосредоточимся на трёх алгоритмах, которые помогут вам освоить основы.

---

### Генерация случайных списков
Для удобства тестирования создадим функцию, которая генерирует случайный список заданного размера. Это поможет нам создавать массивы для примеров.

```python
import random

def generate_random_list(size, min_val=0, max_val=100):
    return [random.randint(min_val, max_val) for _ in range(size)]
```

- **size** — размер списка (в нашем случае будет 6).
- **min_val** и **max_val** — минимальное и максимальное значения элементов (по умолчанию от 0 до 100).

Пример использования:
```python
arr = generate_random_list(6)
print("Случайный список:", arr)
```
Вывод может быть, например: `Случайный список: [45, 12, 67, 8, 34, 91]`.

---
#### 1. Что такое Bubble Sort?
**Bubble Sort** (пузырьковая сортировка) — это простой алгоритм сортировки, который проходит по списку много раз, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке. Название "пузырьковая" появилось, потому что большие элементы как бы "всплывают" к концу списка, как пузырьки в воде.

#### Как работает алгоритм?
1. Начинаем с начала списка и сравниваем каждую пару соседних элементов.  
2. Если первый элемент больше второго, меняем их местами.  
3. Повторяем это для всего списка, пока все элементы не окажутся на своих местах.  

Представьте, что вы выстраиваете книги на полке по росту: вы сравниваете две книги рядом, и если высокая стоит перед низкой, меняете их местами.

#### Подробный пример
Возьмём список из 6 элементов: `[4, 2, 7, 1, 3, 6]`.
##### Проход 1:
- Сравниваем 4 и 2: 4 > 2 → меняем: `[2, 4, 7, 1, 3, 6]`  
- Сравниваем 4 и 7: 4 < 7 → оставляем  
- Сравниваем 7 и 1: 7 > 1 → меняем: `[2, 4, 1, 7, 3, 6]`  
- Сравниваем 7 и 3: 7 > 3 → меняем: `[2, 4, 1, 3, 7, 6]`  
- Сравниваем 7 и 6: 7 > 6 → меняем: `[2, 4, 1, 3, 6, 7]`  
- После первого прохода самый большой элемент (7) оказался в конце.
##### Проход 2:
- Сравниваем 2 и 4: 2 < 4 → оставляем  
- Сравниваем 4 и 1: 4 > 1 → меняем: `[2, 1, 4, 3, 6, 7]`  
- Сравниваем 4 и 3: 4 > 3 → меняем: `[2, 1, 3, 4, 6, 7]`  
- Сравниваем 4 и 6: 4 < 6 → оставляем  
- Сравниваем 6 и 7: 6 < 7 → оставляем  
- Теперь 6 на своём месте.
##### Проход 3 и далее:
Повторяем, пока не отсортируем весь список. После нескольких проходов получится: `[1, 2, 3, 4, 6, 7]`.

#### Реализация на Python
Вот код для Bubble Sort с оптимизацией (проверкой, отсортирован ли список):

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):  # Проходим по всему списку
        swapped = False  # Флаг, чтобы проверить, были ли обмены
        for j in range(0, n - i - 1):  # Сравниваем соседние элементы
            if arr[j] > arr[j + 1]:  # Если текущий больше следующего
                arr[j], arr[j + 1] = arr[j + 1], arr[j]  # Меняем местами
                swapped = True
        if not swapped:  # Если не было обменов, список отсортирован
            break
    return arr

# Пример использования
arr = [4, 2, 7, 1, 3, 6]
sorted_arr = bubble_sort(arr)
print("Отсортированный список:", sorted_arr)  # Вывод: [1, 2, 3, 4, 6, 7]
```

#### Сложность алгоритма
- **Временная сложность**:  
  - В худшем случае (список в обратном порядке): **O(n²)** — много сравнений и обменов.  
  - В лучшем случае (список почти отсортирован): **O(n)** — если добавлена проверка `swapped`.  
- **Пространственная сложность**: **O(1)** — сортировка происходит на месте, без лишней памяти.

#### Примеры на списках из 6 элементов
1. **Почти отсортированный список**: `[1, 2, 3, 5, 4, 6]`  
   - Проход 1: `[1, 2, 3, 4, 5, 6]` (меняем 5 и 4).  
   - Проход 2: Не было обменов → готово!  
2. **Список в обратном порядке**: `[6, 5, 4, 3, 2, 1]`  
   - Проход 1: `[5, 4, 3, 2, 1, 6]`  
   - Проход 2: `[4, 3, 2, 1, 5, 6]`  
   - И так далее, потребуется 5 проходов.

#### Заключение
Bubble Sort прост в понимании и реализации, но он медленный для больших списков из-за сложности **O(n²)**. Он хорош для обучения или маленьких данных, но для больших лучше использовать Quick Sort. Попробуйте запустить код с разными списками, чтобы увидеть, как он работает!

---

### 3. Быстрая сортировка (Quick Sort)

Quick Sort — это алгоритм сортировки, основанный на принципе "разделяй и властвуй". Он выбирает один элемент массива (называемый **опорным**, или *pivot*), делит массив на две части — элементы меньше опорного и элементы больше опорного — и рекурсивно сортирует эти части.

#### Основные шаги алгоритма

1. **Выбор опорного элемента (pivot)**: Это может быть любой элемент массива. Часто выбирают первый, последний или случайный элемент.
2. **Разделение (partitioning)**: Перестраиваем массив так, чтобы все элементы меньше опорного оказались слева от него, а все элементы больше — справа. После этого опорный элемент находится на своем окончательном месте.
3. **Рекурсия**: Повторяем процесс для подмассивов слева и справа от опорного элемента, пока подмассивы не станут размером 0 или 1 (такие массивы уже отсортированы).

---

#### Шаг 1: Выбор опорного элемента
Опорный элемент — это точка, вокруг которой мы делим массив. Способ выбора опорного элемента влияет на эффективность алгоритма:
- **Последний элемент**: Простой выбор, но может привести к плохой производительности на отсортированных массивах.
- **Случайный элемент**: Уменьшает вероятность худшего случая.
- **Средний элемент**: Еще один вариант, иногда используется для баланса.

#### Шаг 2: Разделение массива
После выбора опорного элемента мы:
- Помещаем все элементы, меньшие или равные опорному, в один подмассив (левый).
- Помещаем все элементы, большие опорного, в другой подмассив (правый).
- Опорный элемент занимает место между ними.

#### Шаг 3: Рекурсия
Повторяем процесс для левого и правого подмассивов, пока не дойдем до базового случая: массивов длиной 0 или 1.

---

### Рекурсия и её применение в Quick Sort
#### Что такое рекурсия?
**Рекурсия** — это способ решения задачи, когда функция вызывает саму себя, но с меньшими или изменёнными данными. Представьте, что вы решаете большую задачу, разбивая её на маленькие кусочки, которые похожи на исходную задачу. Это как если бы вы попросили друга помочь вам с работой, а он, в свою очередь, попросил бы другого друга, и так далее, пока работа не будет сделана.

Чтобы рекурсия работала правильно, нужно две важные вещи:
1. **Базовый случай**  
   Это момент, когда задача становится настолько простой, что её можно решить сразу, и рекурсия останавливается. Без этого функция будет вызывать себя бесконечно, как зацикленная пластинка.
2. **Рекурсивный случай**  
   Это шаг, где задача разбивается на меньшие части, и функция вызывает себя с этими частями. Каждый вызов приближает нас к базовому случаю.

#### Простой пример: Считаем ступеньки
Допустим, вы хотите спуститься с лестницы из 5 ступенек и узнать, сколько шагов нужно сделать.  
- Если вы на последней ступеньке (0 ступенек осталось), вы закончили — это **базовый случай**.  
- Если ступенек больше (например, 5), вы делаете шаг вниз и считаете, сколько осталось (4). Это **рекурсивный случай**.  

На Python это будет выглядеть так:

```python
def count_steps(steps):
    if steps == 0:  # Базовый случай: нет ступенек
        return 0
    else:  # Рекурсивный случай: делаем шаг и считаем дальше
        return 1 + count_steps(steps - 1)

print(count_steps(5))  # Вывод: 5
```

Что происходит?  
- `count_steps(5)` → 1 + `count_steps(4)`  
- `count_steps(4)` → 1 + `count_steps(3)`  
- `count_steps(3)` → 1 + `count_steps(2)`  
- `count_steps(2)` → 1 + `count_steps(1)`  
- `count_steps(1)` → 1 + `count_steps(0)`  
- `count_steps(0)` → 0 (базовый случай)  
- Идём назад: 0 + 1 = 1, 1 + 1 = 2, 2 + 1 = 3, 3 + 1 = 4, 4 + 1 = 5.  

Итог: 5 шагов!

---

#### Как рекурсия помогает в Quick Sort?
**Quick Sort** — это алгоритм сортировки, который использует рекурсию, чтобы разложить задачу на части. Вот как это работает:

1. **Базовый случай**:  
   Если у вас список из одного элемента или пустой, он уже отсортирован. Ничего делать не надо — рекурсия останавливается.

2. **Рекурсивный случай**:  
   - Выбираем один элемент в списке, который называется **опорным** (например, первый или последний).  
   - Делим список на две части: все элементы меньше опорного и все больше опорного.  
   - Применяем Quick Sort к этим двум частям, вызывая функцию сортировки для каждой из них.  
   - В конце соединяем отсортированные части и опорный элемент.

Пример: Список `[5, 2, 9, 1, 7]`  
- Выбираем опорный элемент, допустим, 5.  
- Делим: `[2, 1]` (меньше 5) и `[9, 7]` (больше 5).  
- Рекурсивно сортируем `[2, 1]` → `[1, 2]` (вызываем Quick Sort для этой части).  
- Рекурсивно сортируем `[9, 7]` → `[7, 9]`.  
- Соединяем: `[1, 2] + [5] + [7, 9]` → `[1, 2, 5, 7, 9]`.

На Python это может выглядеть так:
```python
def quick_sort(arr):
    if len(arr) <= 1:  # Базовый случай
        return arr
    else:  # Рекурсивный случай
        pivot = arr[0]  # Опорный элемент
        left = [x for x in arr[1:] if x <= pivot]  # Элементы меньше или равны
        right = [x for x in arr[1:] if x > pivot]  # Элементы больше
        return quick_sort(left) + [pivot] + quick_sort(right)  # Рекурсия

arr = [5, 2, 9, 1, 7]
print(quick_sort(arr))  # Вывод: [1, 2, 5, 7, 9]
```

#### Почему это работает?
Рекурсия разбивает большую задачу (отсортировать весь список) на маленькие (отсортировать части). Каждый раз список становится меньше, пока не дойдёт до базового случая. Это как если бы вы разбирали большую кучу вещей на маленькие стопки, сортируя каждую по очереди.

Теперь, когда вы понимаете рекурсию, Quick Sort становится проще — это просто способ делить и сортировать с её помощью!

---
## Сложность алгоритма

- **Средняя сложность**: **O(n log n)**  
  Это достигается, когда массив делится примерно пополам на каждом шаге. Логарифмическое число уровней рекурсии (log n) умножается на линейное время разделения (n).

- **Худшая сложность**: **O(n²)**  
  Происходит, если опорный элемент всегда оказывается минимальным или максимальным, и массив делится неравномерно (например, один подмассив пустой). Такое случается с уже отсортированными или почти отсортированными массивами при неудачном выборе опорного элемента.

- **Лучшая сложность**: **O(n log n)**  
  Достигается при идеальном разделении массива на равные части.

Чтобы избежать худшего случая, можно случайно выбирать опорный элемент.

---

## Примеры на массивах размером 6
Рассмотрим два примера: "хороший" вариант (случайный массив) и "плохой" вариант (отсортированный массив).

### "Хороший" вариант
Массив: `[4, 2, 7, 1, 3, 6]`
#### Шаг 1: Первый уровень
- Выбираем опорный элемент: последний, `6`.
- Разделяем:
  - Меньше 6: `[4, 2, 1, 3]`
  - Больше 6: `[7]`
  - Опорный: `6`
- Результат: `[4, 2, 1, 3]` + `[6]` + `[7]`
#### Шаг 2: Сортируем левый подмассив `[4, 2, 1, 3]`
- Опорный: `3`.
- Разделяем:
  - Меньше 3: `[2, 1]`
  - Больше 3: `[4]`
  - Опорный: `3`
- Результат: `[2, 1]` + `[3]` + `[4]`
#### Шаг 3: Сортируем `[2, 1]`
- Опорный: `1`.
- Разделяем:
  - Меньше 1: `[]`
  - Больше 1: `[2]`
  - Опорный: `1`
- Результат: `[]` + `[1]` + `[2]` = `[1, 2]`
#### Шаг 4: Собираем назад
- Из шага 2: `[1, 2]` + `[3]` + `[4]` = `[1, 2, 3, 4]`.
- Из шага 1: `[1, 2, 3, 4]` + `[6]` + `[7]` = `[1, 2, 3, 4, 6, 7]`.

Итог: `[1, 2, 3, 4, 6, 7]`.

### "Плохой" вариант
Массив: `[1, 2, 3, 4, 5, 6]` (уже отсортирован)
#### Шаг 1: Первый уровень
- Опорный: `6`.
- Разделяем:
  - Меньше 6: `[1, 2, 3, 4, 5]`
  - Больше 6: `[]`
  - Опорный: `6`
- Результат: `[1, 2, 3, 4, 5]` + `[6]` + `[]`
#### Шаг 2: Сортируем `[1, 2, 3, 4, 5]`
- Опорный: `5`.
- Разделяем:
  - Меньше 5: `[1, 2, 3, 4]`
  - Больше 5: `[]`
  - Опорный: `5`
- Результат: `[1, 2, 3, 4]` + `[5]` + `[]`
#### Шаг 3: Сортируем `[1, 2, 3, 4]`
- Опорный: `4`.
- Разделяем:
  - Меньше 4: `[1, 2, 3]`
  - Больше 4: `[]`
  - Опорный: `4`
- Результат: `[1, 2, 3]` + `[4]` + `[]`

И так далее. Каждый раз один подмассив пустой, что приводит к **O(n²)**.

---
### Простая реализация "в лоб"
Здесь опорный элемент — всегда последний.
```python
def quick_sort(arr):
    # Базовый случай: если массив пустой или из одного элемента
    if len(arr) <= 1:
        return arr
    
    # Опорный элемент — последний
    pivot = arr[-1]
    
    # Элементы меньше или равные опорному
    left = [x for x in arr[:-1] if x <= pivot]
    
    # Элементы больше опорного
    right = [x for x in arr[:-1] if x > pivot]
    
    # Рекурсивно сортируем и соединяем
    return quick_sort(left) + [pivot] + quick_sort(right)
```

Пример:
```python
arr = [4, 2, 7, 1, 3, 6]
sorted_arr = quick_sort(arr)
print("Отсортированный список:", sorted_arr)
```
Вывод: `Отсортированный список: [1, 2, 3, 4, 6, 7]`.

Недостаток: на отсортированных массивах работает медленно.

### Оптимальная реализация с случайным выбором
Используем случайный опорный элемент для уменьшения вероятности худшего случая.
```python
import random

def quick_sort_random(arr):
    # Базовый случай
    if len(arr) <= 1:
        return arr
    
    # Случайный индекс опорного элемента
    pivot_index = random.randint(0, len(arr) - 1)
    pivot = arr[pivot_index]
    
    # Элементы меньше опорного
    left = [x for x in arr if x < pivot]
    
    # Элементы равные опорному (для учета повторяющихся элементов)
    middle = [x for x in arr if x == pivot]
    
    # Элементы больше опорного
    right = [x for x in arr if x > pivot]
    
    # Рекурсивно сортируем и соединяем
    return quick_sort_random(left) + middle + quick_sort_random(right)
```

Пример:
```python
arr = generate_random_list(6)
print("Случайный список:", arr)
sorted_arr = quick_sort_random(arr)
print("Отсортированный список:", sorted_arr)
```
Вывод, например:  
`Случайный список: [45, 12, 67, 8, 34, 91]`  
`Отсортированный список: [8, 12, 34, 45, 67, 91]`.

Преимущество: случайный выбор опорного элемента делает худший случай менее вероятным.


Quick Sort — это эффективный алгоритм сортировки со средней сложностью **O(n log n)** Однако его производительность зависит от выбора опорного элемента. Простая реализация с фиксированным выбором (например, последний элемент) может привести к **O(n²)** на отсортированных данных, тогда как случайный выбор опорного элемента улучшает поведение в среднем случае. Попробуйте протестировать обе реализации на разных массивах, используя функцию `generate_random_list`!


---
#### 2. Сортировка вставками (Insertion Sort)
**Сортировка вставками** — это простой и интуитивный алгоритм, который напоминает, как люди сортируют карты в руке. Он особенно эффективен для небольших списков или наборов данных, которые уже почти отсортированы.

##### Как работает Insertion Sort?
Алгоритм делит список на две части: отсортированную (слева) и неотсортированную (справа). На каждом шаге он берёт элемент из неотсортированной части и вставляет его в правильное место в отсортированной части. Вот пошаговый процесс:

1. Начинаем с первого элемента — он считается отсортированным.
2. Берём следующий элемент и сравниваем его с элементами отсортированной части, двигаясь справа налево.
3. Если текущий элемент меньше, сдвигаем большие элементы вправо, освобождая место.
4. Вставляем элемент в найденную позицию.
5. Повторяем процесс для всех оставшихся элементов.

**Пример работы на списке `[4, 2, 7, 1, 3, 6]`:**

- **Шаг 1:** `[4]` — первый элемент, считаем его отсортированным.
- **Шаг 2:** Берём `2`. Сравниваем с `4` (`2 < 4`), сдвигаем `4` вправо и вставляем `2`: `[2, 4]`.
- **Шаг 3:** Берём `7`. Сравниваем с `4` (`7 > 4`), оставляем на месте: `[2, 4, 7]`.
- **Шаг 4:** Берём `1`. Сравниваем с `7`, `4`, `2` (`1` меньше всех), сдвигаем их вправо и вставляем `1`: `[1, 2, 4, 7]`.
- **Шаг 5:** Берём `3`. Сравниваем с `7`, `4`, `2` (`2 < 3 < 4`), вставляем между `2` и `4`: `[1, 2, 3, 4, 7]`.
- **Шаг 6:** Берём `6`. Сравниваем с `7` (`6 < 7`), вставляем перед `7`: `[1, 2, 3, 4, 6, 7]`.

**Реализация на Python :**

```python
def insertion_sort(arr):
    # Проходим по списку, начиная со второго элемента (индекс 1)
    for i in range(1, len(arr)):
        key = arr[i]  # Текущий элемент, который нужно вставить
        j = i - 1     # Индекс последнего элемента отсортированной части
        # Пока не дошли до начала списка и элемент слева больше текущего
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # Сдвигаем больший элемент вправо
            j -= 1               # Двигаемся влево по отсортированной части
        arr[j + 1] = key        # Вставляем текущий элемент в освободившееся место
    return arr

# Пример использования
arr = [4, 2, 7, 1, 3, 6]
print("Исходный список:", arr)
sorted_arr = insertion_sort(arr)
print("Отсортированный список:", sorted_arr)  # Вывод: [1, 2, 3, 4, 6, 7]
```

**Пошаговое пояснение работы кода на примере `[4, 2, 7, 1]`:**
1. **i = 1:** `key = 2`, `j = 0`. Сравниваем `arr[0] = 4` с `2`. Так как `4 > 2`, сдвигаем `4` вправо: `[4, 4, 7, 1]`. `j` становится `-1`, вставляем `2`: `[2, 4, 7, 1]`.
2. **i = 2:** `key = 7`, `j = 1`. `arr[1] = 4 < 7`, цикл не запускается, `7` остаётся на месте: `[2, 4, 7, 1]`.
3. **i = 3:** `key = 1`, `j = 2`. Сравниваем: `7 > 1` → `[2, 4, 7, 7]`, `j = 1`; `4 > 1` → `[2, 4, 4, 7]`, `j = 0`; `2 > 1` → `[2, 2, 4, 7]`, `j = -1`. Вставляем `1`: `[1, 2, 4, 7]`.

##### Временная сложность:
- **Худший случай:** \( O(n^2) \) — список отсортирован в обратном порядке.
- **Лучший случай:** \( O(n) \) — список уже почти отсортирован, требуется минимум сдвигов.
- **Средний случай:** \( O(n^2) \).

**Когда использовать:**  
Insertion Sort идеален для небольших списков или данных, которые уже частично упорядочены. В таких случаях он работает быстрее многих других алгоритмов.

---
#### 2. Сортировка выбором (Selection Sort)
**Сортировка выбором** — ещё один простой алгоритм, который часто используется для обучения. Он находит минимальный элемент в неотсортированной части списка и перемещает его в начало.

##### Как работает Selection Sort?
1. Находим минимальный элемент в списке и меняем его местами с первым элементом.
2. Повторяем процесс для оставшейся неотсортированной части.
3. Продолжаем, пока весь список не будет отсортирован.

**Пример:** `[4, 2, 7, 1, 3, 6]`
- **Шаг 1:** Минимум `1`, меняем с `4`: `[1, 2, 7, 4, 3, 6]`.
- **Шаг 2:** В `[2, 7, 4, 3, 6]` минимум `2`, уже на месте.
- **Шаг 3:** В `[7, 4, 3, 6]` минимум `3`, меняем с `7`: `[1, 2, 3, 4, 7, 6]`.
- **Шаг 4:** В `[4, 7, 6]` минимум `4`, на месте.
- **Шаг 5:** В `[7, 6]` минимум `6`, меняем с `7`: `[1, 2, 3, 4, 6, 7]`.

**Реализация на Python:**
```python
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [4, 2, 7, 1, 3, 6]
sorted_arr = selection_sort(arr)
print("Отсортированный список:", sorted_arr)  # Вывод: [1, 2, 3, 4, 6, 7]
```

##### Временная сложность:
- **Худший, лучший и средний случаи:** \( O(n^2) \).

**Когда использовать:**  
Selection Sort прост в реализации, но неэффективен для больших списков. Подходит для учебных целей или маленьких наборов данных.

---

### Итог
- **Insertion Sort** — для небольших или почти отсортированных списков.
- **Selection Sort** — простой, но медленный для больших данных.
- **Quick Sort** — быстрый и эффективный для больших наборов.

---

## Что такое Merge Sort?
Merge Sort — это алгоритм сортировки, основанный на принципе "разделяй и властвуй". Он делит исходный массив на меньшие части, сортирует их рекурсивно, а затем объединяет (сливает) отсортированные части в один отсортированный массив. Этот алгоритм стабилен (сохраняет порядок равных элементов) и имеет предсказуемую временную сложность, что делает его надежным выбором для многих задач.

### Основные шаги алгоритма
1. **Разделение**: Делим массив на две примерно равные половины.
2. **Рекурсия**: Рекурсивно сортируем каждую из половин.
3. **Слияние**: Объединяем две отсортированные половины в один отсортированный массив.

Давайте разберем эти шаги подробно.

## Подробное объяснение алгоритма
### Шаг 1: Разделение
- Берем исходный массив и делим его пополам.
- Продолжаем деление каждой части, пока не дойдем до массива из одного элемента.
- Массив из одного элемента считается отсортированным (это базовый случай рекурсии).

### Шаг 2: Слияние
- После того как подмассивы отсортированы, мы их объединяем.
- Для слияния двух отсортированных массивов:
  - Сравниваем элементы из обоих массивов по очереди.
  - Добавляем меньший элемент в результирующий массив.
  - Продолжаем, пока не обработаем все элементы обоих массивов.
- Если в одном из массивов остались элементы, добавляем их в конец результата.


### Временная сложность: **O(n log n)**
- **Разделение**: Массив делится на две части на каждом уровне рекурсии. Глубина рекурсии — это примерно **log n** уровней (логарифм по основанию 2 от размера массива).
- **Слияние**: На каждом уровне рекурсии мы сливаем все подмассивы, что занимает **O(n)** времени (так как сравниваем и перемещаем каждый элемент ровно один раз).
- Итог: **O(log n)** уровней * **O(n)** операций на каждом уровне = **O(n log n)**.

Merge Sort всегда работает за **O(n log n)** независимо от исходных данных, что отличает его от алгоритмов вроде быстрой сортировки, где сложность может ухудшаться до **O(n²)** в худшем случае.

### Пространственная сложность: **O(n)**
- Для слияния подмассивов требуется дополнительная память для временного хранения результатов.
- В худшем случае мы используем дополнительный массив размером **n**, что дает **O(n)**.

Теперь перейдем к примерам, чтобы увидеть алгоритм в действии.

---

### Примеры на массивах размером 6
Мы рассмотрим два случая: "хороший" (случайный массив) и "плохой" (уже отсортированный массив). Для Merge Sort нет "плохого" случая в плане временной сложности — он всегда работает за **O(n log n)**, но мы разберем оба варианта для наглядности. Размер массивов — 6, как указано в запросе (`len(arr) = 6`).

### "Хороший" вариант: случайный массив
Массив: `[4, 2, 7, 1, 3, 6]`
#### Шаг 1: Разделение
1. Делим `[4, 2, 7, 1, 3, 6]` на:
   - `[4, 2, 7]` и `[1, 3, 6]`.
2. Делим `[4, 2, 7]` на:
   - `[4]` и `[2, 7]`.
   - Делим `[2, 7]` на `[2]` и `[7]`.
3. Делим `[1, 3, 6]` на:
   - `[1]` и `[3, 6]`.
   - Делим `[3, 6]` на `[3]` и `[6]`.

На этом этапе у нас есть массивы из одного элемента: `[4]`, `[2]`, `[7]`, `[1]`, `[3]`, `[6]`. Каждый из них уже отсортирован.
#### Шаг 2: Слияние
1. Сливаем `[2]` и `[7]`:
   - Сравниваем 2 и 7 → `[2, 7]`.
2. Сливаем `[4]` и `[2, 7]`:
   - Сравниваем 4 и 2 → 2 меньше, добавляем 2.
   - Сравниваем 4 и 7 → 4 меньше, добавляем 4.
   - Остался 7 → добавляем 7.
   - Результат: `[2, 4, 7]`.
3. Сливаем `[3]` и `[6]`:
   - Сравниваем 3 и 6 → `[3, 6]`.
4. Сливаем `[1]` и `[3, 6]`:
   - Сравниваем 1 и 3 → 1 меньше, добавляем 1.
   - Сравниваем 3 и 6 → 3 меньше, добавляем 3.
   - Остался 6 → добавляем 6.
   - Результат: `[1, 3, 6]`.
5. Сливаем `[2, 4, 7]` и `[1, 3, 6]`:
   - Сравниваем 2 и 1 → 1 меньше, добавляем 1.
   - Сравниваем 2 и 3 → 2 меньше, добавляем 2.
   - Сравниваем 4 и 3 → 3 меньше, добавляем 3.
   - Сравниваем 4 и 6 → 4 меньше, добавляем 4.
   - Сравниваем 7 и 6 → 6 меньше, добавляем 6.
   - Остался 7 → добавляем 7.
   - Результат: `[1, 2, 3, 4, 6, 7]`.

Итог: `[1, 2, 3, 4, 6, 7]`.

### "Плохой" вариант: отсортированный массив
Массив: `[1, 2, 3, 4, 5, 6]`
#### Шаг 1: Разделение
1. Делим `[1, 2, 3, 4, 5, 6]` на:
   - `[1, 2, 3]` и `[4, 5, 6]`.
2. Делим `[1, 2, 3]` на:
   - `[1]` и `[2, 3]`.
   - Делим `[2, 3]` на `[2]` и `[3]`.
3. Делим `[4, 5, 6]` на:
   - `[4]` и `[5, 6]`.
   - Делим `[5, 6]` на `[5]` и `[6]`.

Базовые массивы: `[1]`, `[2]`, `[3]`, `[4]`, `[5]`, `[6]`.
#### Шаг 2: Слияние
1. Сливаем `[2]` и `[3]`:
   - Сравниваем 2 и 3 → `[2, 3]`.
2. Сливаем `[1]` и `[2, 3]`:
   - Сравниваем 1 и 2 → 1 меньше, добавляем 1.
   - Сравниваем 2 и 3 → 2 меньше, добавляем 2.
   - Остался 3 → добавляем 3.
   - Результат: `[1, 2, 3]`.
3. Сливаем `[5]` и `[6]`:
   - Сравниваем 5 и 6 → `[5, 6]`.
4. Сливаем `[4]` и `[5, 6]`:
   - Сравниваем 4 и 5 → 4 меньше, добавляем 4.
   - Сравниваем 5 и 6 → 5 меньше, добавляем 5.
   - Остался 6 → добавляем 6.
   - Результат: `[4, 5, 6]`.
5. Сливаем `[1, 2, 3]` и `[4, 5, 6]`:
   - Сравниваем 1 и 4 → 1 меньше, добавляем 1.
   - Сравниваем 2 и 4 → 2 меньше, добавляем 2.
   - Сравниваем 3 и 4 → 3 меньше, добавляем 3.
   - Сравниваем 4 и 5 → 4 меньше, добавляем 4.
   - Сравниваем 5 и 6 → 5 меньше, добавляем 5.
   - Остался 6 → добавляем 6.
   - Результат: `[1, 2, 3, 4, 5, 6]`.

Итог: `[1, 2, 3, 4, 5, 6]`.

Как видно, даже для отсортированного массива Merge Sort выполняет все шаги, сохраняя сложность **O(n log n)**.

---

Теперь реализуем алгоритм двумя способами: простой "в лоб" и более оптимальной версией.

### Простая реализация "в лоб"
Эта версия использует рекурсию и создает новые списки на каждом шаге.

```python
def merge(left, right):
    result = []
    i = j = 0
    # Сравниваем элементы из left и right
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    # Добавляем оставшиеся элементы
    result += left[i:]
    result += right[j:]
    return result

def merge_sort(arr):
    # Базовый случай: массив из 0 или 1 элемента уже отсортирован
    if len(arr) <= 1:
        return arr
    # Делим массив пополам
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])   # Рекурсия на левой половине
    right = merge_sort(arr[mid:])  # Рекурсия на правой половине
    return merge(left, right)      # Слияние результатов
```

Пример использования:
```python
arr = [4, 2, 7, 1, 3, 6]
sorted_arr = merge_sort(arr)
print("Отсортированный список:", sorted_arr)
```
Вывод:  
`Отсортированный список: [1, 2, 3, 4, 6, 7]`.

**Недостаток**: Использование срезов (`arr[:mid]` и `arr[mid:]`) создает новые списки, что увеличивает потребление памяти.

### Оптимальная реализация
Эта версия работает с индексами и сортирует массив на месте, минимизируя создание новых списков.

```python
def merge(arr, left, mid, right):
    # Создаем временный массив для слияния
    temp = [0] * (right - left + 1)
    i, j, k = left, mid + 1, 0
    
    # Сливаем две части: arr[left..mid] и arr[mid+1..right]
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp[k] = arr[i]
            i += 1
        else:
            temp[k] = arr[j]
            j += 1
        k += 1
    
    # Добавляем оставшиеся элементы из левой части
    while i <= mid:
        temp[k] = arr[i]
        i += 1
        k += 1
    # Добавляем оставшиеся элементы из правой части
    while j <= right:
        temp[k] = arr[j]
        j += 1
        k += 1
    
    # Копируем временный массив обратно в исходный
    for idx in range(left, right + 1):
        arr[idx] = temp[idx - left]

def merge_sort(arr, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    # Базовый случай: если подмассив из одного элемента
    if left >= right:
        return
    # Делим массив пополам
    mid = (left + right) // 2
    merge_sort(arr, left, mid)      # Рекурсия на левой половине
    merge_sort(arr, mid + 1, right) # Рекурсия на правой половине
    merge(arr, left, mid, right)    # Слияние
```

Пример использования:
```python
arr = generate_random_list(6)
print("Случайный список:", arr)
merge_sort(arr)
print("Отсортированный список:", arr)
```
Вывод, например:  
`Случайный список: [45, 12, 67, 8, 34, 91]`  
`Отсортированный список: [8, 12, 34, 45, 67, 91]`.

**Преимущество**: Эта версия более эффективна по памяти, так как не создает новые списки на каждом шаге, а использует индексы и один временный массив для слияния.








